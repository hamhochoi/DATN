\newcommand{\blank}[1]{\hspace*{#1}\linebreak[0]}
\chapter{Xây dựng hệ thống IoT và thiết kế cơ chế truy vấn ngữ nghĩa}
\section{Xây dựng hệ thống IoT}
\subsection{Phần cứng}
Các thiết bị IoT được cài đặt trên 3 khu vực trong phòng 609 thư viện Tạ Quang Bửu. Trong mỗi phòng, có một máy tính nhỏ Raspberry Pi 3, cài đặt nền tảng IoT để quản lý các thiết bị trong phòng. Trong mỗi phòng, gồm :
\begin{itemize}
	\item Một cảm biến chuyển động
	\item Một cảm biến ánh sáng
	\item Một cảm biến nhiệt độ, độ ẩm
	\item Ba đèn LED tượng trưng cho ba thiết bị IoT có khả năng thiết lập các trạng thái khác nhau (bật/tắt).
\end{itemize}
Các cảm biến và đèn LED trong mỗi phòng được cài đặt vào hai hộp đại diện cho hai thiết bị thông minh. Thiết bị thứ nhất chứa cảm biến chuyển động và ba đèn LED; thiết bị thứ hai chứa cảm biến ánh sáng, cảm biến nhiệt độ-độ ẩm. 
\clearpage

\begin{figure}
	\center
	\includegraphics[scale=1]{image/hop_1}
	\label{fig:2hop}
	%\caption{Hai hộp đại diện cho hai "vật"}
\end{figure}

\begin{figure}
	\center
	\includegraphics[scale=1]{image/hop_2}
	\label{fig:2hop}
	\caption{Hai hộp đại diện cho hai thiết bị thông minh}
\end{figure}

Để lấy được dữ liệu từ các thiết bị trên, ta sử dụng board vi mạch xử lý Arduino Uno. Tuy nhiên, vi mạch này không có chức năng gửi dữ liệu thông qua mạng wifi, do đó, cần phải lắp thêm module ESP8266 để gửi dữ liệu từ Arduino, qua ESP8266 rồi gửi lên platform.
\subsection{Các giao thức sử dụng}
Giao thức được dùng để truyền tải dữ liệu từ ESP8266 lên nền tảng IoT là MQTT thông qua mạng wifi. Sau khi đã xác định được các thành phần phần cứng và giao thức sử dụng để truyền tin giữa các thiết bị tới nền tảng IoT, tôi xây dựng mô hình triển khai như sau: \\
\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.6]{image/mo_hinh_trien_khai_phan_cung}
	\caption{Mô hình triển khai hệ thống}
	
	\label{fig:mo_hinh_trien_khai_phan_cung}
\end{figure}

Hệ thống triển khai thực tế :\\

\begin{figure}[h!]
	\center
	\includegraphics[scale=1]{image/hop_1}
	\includegraphics[scale=1]{image/hop_2}
\end{figure}

\begin{figure}[h!]
	\center
	%\includegraphics[scale=1]{image/hop_1}
	%\includegraphics[scale=1]{image/hop_2}
	\includegraphics[scale=0.4]{image/hop_3}	
	\includegraphics[scale=0.5]{image/hop_4}
	\includegraphics[scale=1]{image/hop_5}
	\caption{Triển khai phần cứng trên phòng 609 Thư viện TQB}
	\label{fig:trien_khai_phan_cung}
\end{figure}
%\clearpage 


\subsection{Các nền tảng IoT sử dụng}
Hiện nay, trong thực tế có rất nhiều các nền tảng IoT được sử dụng, cả các platform nguồn đóng và nguồn mở. Các nền tảng IoT mã nguồn đóng thường được các công ty hoạt động vì lợi nhuận xây dựng, ví dụ như IBM, Amazon, ... còn các nền tảng IoT mã nguồn mở thường được cộng đồng mã nguồn mở hoặc các công ty hoạt động phi lợi nhuận xây dựng. Do đề tài chỉ mang mục đích nghiên cứu, nên tôi sử ba nền tảng IoT mã nguồn mở để mô tả tính không đồng nhất về cấu trúc dữ liệu của các platform và cách ánh xạ các cấu trúc không đồng nhất này về dạng chuẩn chung của ontology. Ba platform được sử dụng là OpenHAB, HomeAssistant và ThingsBoard.

OpenHAB là một nền tảng IoT được dùng chủ yếu để quản lý các thiết bị trong ngôi nhà thông minh. Các ưu điểm của OpenHAB là:
\begin{itemize}
	\item Có khả năng tích hợp các thiết bị, hệ thống khác.
	\item Cung cấp giao diện thống nhất cho người dùng và người dùng có thể tạo ra các luật dựa trên thông tin của các thiết bị trong hệ thống.
	\item Cung cấp một công cụ linh động để tạo ra một ngôi nhà tự động. OpenHAB hỗ trợ tự thêm rất nhiều loại thiết bị, giao thức phổ biến trong IoT. 
\end{itemize}
OpenHAB cung cấp tập các Restful API để các chương trình khác có thể sử dụng để lấy thông tin về các thiết bị hoặc ra lệnh cho các thiết bị.
%\clearpage

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.3]{image/openhab} \\
	\caption{Giao diện quản lý thiết bị của platform OpenHAB}
	\label{fig:giao_dien_openhab}
\end{figure}

Home Assistant là một nền tảng IoT mã nguồn mở ưu tiên quản lý các thiết bị trong ngôi nhà thông minh và có quan tâm tới tính riêng tư. Được cộng đồng lớn mạnh trên thế giới phát triển. Home Assistant phù hợp chạy trên Raspberry Pi hoặc một máy chủ tại chỗ. Home Assistant cũng lượng lớn hỗ trợ các thiết bị thông minh trên thị trường cũng như các giao thức phổ biến được sử dụng trong IoT. Giống với OpenHAB, Home Assistant cũng cung cấp các Restful API để lấy dữ liệu của thiết bị, đồng thời điều khiển các thiết bị qua các API này.
\clearpage

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.3]{image/homeassistant} \\
	\caption{Giao diện quản lý thiết bị của platform Home Assistant}
	\label{fig:giao_dien_homeassistant}
\end{figure}


Thingsboard là một nền tảng IoT mã nguồn mở giúp thu thập dữ liệu, xử lý,trực quan hóa dữ liệu và quản lý các thiết bị. Nó cho phép kết nối các thiết bị thông qua các giao thức chuẩn của IoT như MQTT, CoAp, HTTP. Thingsboard đảm bảo tính mở rộng, tính chịu lỗi và hiệu năng nên người dùng không sợ bị mất dữ liệu. Không giống như OpenHAB chưa có tính bảo mật dữ liệu, hay cơ chế bảo mật yếu Home Assistant, Thingsboard có cơ chế bảo mật dữ liệu của các thiết bị thông qua Token. Để truy cập được vào các thiết bị, bắt buộc phải biết token của các thiết bị này.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.3]{image/thingsboard} \\
	\caption{Giao diện quản lý thiết bị của platform Thingsboard}
	\label{fig:giao_dien_thingsboard}
\end{figure}


\section{Xây dựng ontology}
Sau một thời gian làm việc, tôi đã xây dựng được một ontology như hình vẽ:

%\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.2, center]{image/ontology-2}
	\caption{ontology cho lĩnh vực nhà thông minh}
\end{figure}


Dưới đây là các bước xây dựng ontology mà tôi đã thực hiện:\\
\underline{Bước 1:} Xác định lĩnh vực và phạm vi của ontology \\
Lĩnh vực cần xây dựng ontology là IoT. Tuy nhiên, lĩnh vực IoT rất rộng lớn, gồm đa dạng các thiết bị, cảm biến và gồm nhiều khái niệm. Do đó, việc giới hạn phạm vi xây dựng ontology trong đề tài này là công việc quan trọng. Từ đó, tôi giới hạn phạm vi nghiên cứu của đề tài là lĩnh vực IoT trong nhà thông minh gồm có các thành phần: các cảm biến, các thiết bị, các nền tảng IoT, các ứng dụng/phạm vi sử dụng các nền tảng IoT. 
Mục đích sử dụng của ontology là để tạo ra các câu truy vấn ngữ nghĩa đơn giản. Một số câu hỏi ontology cần có thể trả lời được như:
\begin{itemize}
	\item Một khái niệm có những thuộc tính tương ứng nào?
	\item Một thực thể có các mối quan hệ với các thực thể nào khác?
	\item ...
\end{itemize}
Ngoài ra, ontology cũng cần có khả năng mở rộng so với các thành phần trong ngôi nhà thông minh. 

\underline{Bước 2:} Xem xét việc kế thừa các Ontology có sẵn: \\
Mặc dù đã tồn tại nhiều ontology như đã liệt kê trong chương 2, tuy nhiên, các ontology này chủ yếu được viết theo ngôn ngữ RDF, OWL dựa trên nền tảng web. Hơn nữa, các ontology này khá phức tạp, không phù hợp với phạm vi của đề tài. Do đó, tôi chỉ kế thừa các khái niệm, thuộc tính và các mối quan hệ trong các ontology này để xây dựng ontology của mình.

\underline{Bước 3:} Liệt kê các thuật ngữ quan trọng trong Ontology	\\
Một số khái niệm quan trọng trong lĩnh vực nhà thông minh: 
\begin{itemize}
	\item Smart Context: là một phạm vi triển khai hoặc một ứng dụng trong IoT. Đây sẽ là thành phần trên nhất trong cây phân cấp các khái niệm. Một smart context có thể chứa các smart context khác; một smart context cũng có thể nằm trong một smart context khác.
	\item Platform: là một phần mềm gồm nhiều thành phần, cho phép kết nối, quản lý và tự động hóa việc kết nối các thiết bị trong môi trường IoT. Nó kết nối các thiết bị phần cứng với nhau, cũng như với cloud bằng việc sử dụng linh hoạt các giao thức kết nối, cung cấp các cơ chế bảo mật và cung cấp năng lực xử lý dữ liệu.
	\item Source: Là một thiết bị vật lý hoặc thiết bị ảo. Source sẽ sinh ra dữ liệu về môi trường hay bất kỳ thứ gì mà nó theo dõi. Một Source có thể là một Thing, Gateway hay một Process Unit.
	\item Thing: Là một thiết bị, bao gồm một hoặc một tập hợp các cảm biến
	\item Gateway: Là một thiết bị vật lý hay một trình phần mềm phục vụ như là một điểm kết nối giữa các thiết bị thông minh, các cảm biến với cloud.
	\item Container: Là một thiết bị ảo để theo dõi các tài nguyên trong một hệ thống IoT như CPU, RAM, ổ đĩa, …
	\item Log: là dữ liệu được sinh ra từ Source. Các tệp tin log có thể được dùng để lấy ra các thông tin lịch sử của dữ liệu, trạng thái theo dõi các thiết bị, …
	\item Metric được sử dụng để nhấn mạnh các loại độ đo khác nhau của dữ liệu trong IoT.  Một số loại Metric có thể như Enumeration, Gauge, Counter, Histogram, Summary. Mỗi Metric có các đơn vị tương ứng như Percent, Time, Degree. Mỗi Source đều có một hoặc nhiều Metric của nó.
	\item Data Point: Được tạo ra khi một Source hoạt động. Dựa trên thông tin về Metric của một Source, dữ liệu sẽ có DataType, DataValue phù hợp.
\end{itemize}
\underline{Bước 4:} Xây dựng các lớp/khái niệm và cấu trúc lớp/khái niệm phân cấp: \\
Xây dựng theo kiểu trên xuống, ta nhận thấy Smart Context là khái niệm có mức độ tổng quát cao nhất, là gốc của đồ thị. Các khái niệm Log, Platform, Source, Metric, Data Point là các khái niệm trung gian. Các khái niệm Thing, Gateway, Container, Percent, Time, Degree, … là các khái niệm lá. 

\underline{Bước 5:} Định nghĩa các thuộc tính và quan hệ cho lớp:	\\
Các thuộc tính của các khái niệm trong ontology:
\hspace{0mm}Smart context có các thuộc tính:
\begin{itemize}
	\item SmartContextId: định danh duy nhất của một smart context
	\item SmartContextName: tên của một smartcontext
\end{itemize} 
\hspace{0mm}Platform có các thuộc tính:
\begin{itemize}
	\item PlatformId: định danh duy nhất của một platform
	\item PlatformName: tên của platform
	\item PlatformType: loại platform
	\item PlatformHost: địa chỉ của máy cài đặt platform này
	\item PlatformPort: Cổng cài đặt platform	
	\item PlatformStatus: trạng thái hoạt động của platform
\end{itemize}
\hspace{0mm}Source có các thuộc tính:
\begin{itemize}
	\item SourceId: Định danh toàn cục duy nhất của một Source
	\item EndPoint: Địa chỉ của Source
	\item SourceStatus: Trạng thái hoạt động của Source
	\item Description: Mô tả về Source
	\item SourceType: loại Source	
	\item Label: nhãn của Source
	\item LocalId: Địa chỉ cục bộ của Source
\end{itemize}
\hspace{0mm}Metric có các thuộc tính:
\begin{itemize}
	\item MetricId: định danh toàn cục duy nhất của một Metric
	\item MetricName: tên của một Metric
	\item MetricLocalId: định danh cục bộ của một Metric
	\item MetricType: loại Metric
	\item Unit: đơn vị của Metric
	\item ValueDomain: trường giá trị để ánh xạ các khác nhau trong việc biểu diễn các giá trị dữ liệu của cùng một thiết bị nhưng trong các platform khác nhau. Ví dụ, cùng một cảm biến nhiệt độ, nhưng OpenHAB biểu diễn giá trị của nó là 0/1, HomeAssistant biểu diễn giá trị là on/off.
\end{itemize}
\hspace{0mm}Data Point có các thuộc tính:
\begin{itemize}
	\item DataPointId: định danh duy nhất của một Data Point
	\item DataType: Kiểu dữ liệu của một Data Point
	\item time: thời điểm Data Point được thu nhận
	\item value: giá trị của Data Point
\end{itemize}
\hspace{0mm}Log có các thuộc tính:
\begin{itemize}
	\item time: thời điểm ghi log
	\item message: nội dung của log
\end{itemize}
\hspace{0mm}Mối quan hệ của các khái niệm:
\hspace{0mm}Smart Context
\begin{itemize}
	\item isSubSmartContext: smart context nằm trong smart context khác 
	\item hasSmartContextId: smart context chứa smart context khác.
	\item hasPlatform: smart context chứa platform nào.
\end{itemize}
\hspace{0mm}Platform:
\begin{itemize}
	\item hasSource: Platform chứa những Source nào
\end{itemize}
\hspace{0mm}Source:
\begin{itemize}
	\item hasMetric: Source chứa những Metric nào
\end{itemize}
\hspace{0mm}Metric:
\begin{itemize}
	\item hasDataPoint: Metric chứa những Data Point nào
\end{itemize}
\underline{Bước 6:} Định nghĩa các ràng buộc của các thuộc tính
\hspace{0mm}Các ràng buộc của các thuộc tính:
\hspace{0mm}Smart context: 
\begin{itemize}
	\item SmartContextId: phải là một kiểu String
	\item SmartContextName: phải là một kiểu String
\end{itemize}
\hspace{0mm}Platform:
\begin{itemize}
	\item PlatformId: phải là một kiểu String
	\item PlatformName: phải là một kiểu String
	\item PlatformType: phải là một kiểu String
	\item PlatformHost: phải là một kiểu String
	\item PlatformPort: phải là một kiểu String
	\item PlatformStatus: phải là một kiểu String
\end{itemize}
\hspace{0mm}Source:
\begin{itemize}
	\item SourceId: phải là một kiểu String
	\item EndPoint: phải là một kiểu String
	\item SourceStatus: phải là một kiểu String
	\item Description: phải là một kiểu String
	\item SourceType: phải là một kiểu String
	\item Label: phải là một kiểu String
	\item LocalId: phải là một kiểu String
\end{itemize}
\hspace{0mm}Metric:
\begin{itemize}
	\item MetricId: phải là một kiểu String
	\item MetricName: phải là một kiểu String
	\item MetricLocalId: phải là một kiểu String
	\item MetricType: phải là một kiểu String
	\item Unit: có thể là kiểu của Percent, Time hoặc Degree
	\item ValueDomain: phải là một kiểu String
\end{itemize}
\hspace{0mm}Data Point:
\begin{itemize}
	\item DataPointId: phải là một kiểu String
	\item DataType: phải là một kiểu String
	\item time: phải là một kiểu datetime
	\item value: phải là một kiểu Number
\end{itemize}
\hspace{0mm}Log có các thuộc tính:
\begin{itemize}
	\item time: phải là một kiểu datetime
	\item message: phải là một kiểu String
\end{itemize}

\underline{Bước 7:} Tạo ra các thực thể
Để tạo ra thực thể cho các khái niệm, tôi dùng cú pháp json thay thế cho cú pháp bộ ba: đối tượng - thuộc tính - giá trị với ý nghĩa tương đương.

\hspace{0mm}Một thực thể Smart context: \\
\{\\
\blank{1cm}"SmartContextId" : "HPCC\_id", \\
\blank{1cm}"SmartContextName" : "HPCC",	\\
\blank{1cm}"ParentSmartContextId" : [ ],	\\
\blank{1cm}"SubSmartContextId" : [\\
\blank{2cm}"phong\_sinh\_vien\_id", "phong\_can\_bo\_id","phong\_may\_chu\_id"\\
\blank{1cm}], \\
\blank{1cm}"HasPlatform" : [ ]\\
\}
\clearpage

\hspace{0mm}Một thực thể Platform: \\
\{\\
\blank{1cm}"PlatformId" : "611dc2c1-086d-487f-b44a-2d819764603a", \\
\blank{1cm}"PlatformName" : "homeassistant",	\\
\blank{1cm}"PlatformType" : "",	\\
\blank{1cm}"PlatformHost" : "http://192.168.0.199",\\
\blank{1cm}"PlatformPort" : "8123",\\
\blank{1cm}"PlatformStatus" : "active",\\
\blank{1cm}"HasSource" : [\\
\blank{2cm}"temperature-humidity-light\_homeassistant", "motion\_homeassistant"\\
\blank{1cm}]\\
\}

\hspace{0mm}Một thực thể Source:
\{\\
\blank{1cm}"SourceId" : "motion\_homeassistant",\\
\blank{1cm}"EndPoint" : "http://192.168.0.199:8123/source",\\
\blank{1cm}"SourceStatus" : "active",\\
\blank{1cm}"Description" : "",\\
\blank{1cm}"SourceType" : "thing",\\
\blank{1cm}"Label" : "sensor",\\
\blank{1cm}"LocalId" : "motion\_id",\\
\blank{1cm}"HasMetric" : [\\
\blank{2cm}"binary\_sensor.motion\_detection", "light.green\_light", "light.red\_light", "light.yellow\_light"\\
\blank{1cm}] \\
\}

\hspace{0mm}Một thực thể Metric:\\
\{\\
\blank{1cm}"MetricType":"gauge",\\
\blank{1cm}"MetricLocalId":"b37a79a0-755c-11e9-abce-5bf295b292b2-humidity",\\
\blank{1cm}"MetricId":"b37a79a0-755c-11e9-abce-5bf295b292b2-humidity",\\
\blank{1cm}"CanSetState":"false",\\
\blank{1cm}"HasDatapoint":[\\
\blank{2cm}"b37a79a0-755c-11e9-abce-5bf295b292b2-humidity\_datapoint"\\
\blank{1cm}],\\
\blank{1cm}"MetricStatus":"active",\\
\blank{1cm}"Unit":"",\\
\blank{1cm}"MetricName":"humidity",\\
\blank{1cm}"MetricDomain":"sensor"\\
\}

\hspace{0mm}Một thực thể Data Point:\\
\{\\
\blank{1cm}"DataType":"int",\\
\blank{1cm}"time":"2019-05-13 18:21:26.213131",\\
\blank{1cm}"DatapointId":"b37a79a0-755c-11e9-abce-5bf295b292b2-humidity\_datapoint"\\
\blank{1cm}"value":70\\
\}


\section{Xây dựng driver ánh xạ các dữ liệu trong IoT theo ontology}
Các dữ liệu từ các cảm biến, thiết bị IoT rất khác nhau về cấu trúc. Do trong đề tài này, tất cả các cảm biến, thiết bị đều được gắn với một platform; mỗi platform biểu diễn dữ liệu thu được từ các cảm biến, thiết bị theo một định dạng chuẩn riêng ta phải ánh xạ các định dạng dữ liệu chuẩn của các platform về một dạng chung. Để làm được điều này, ta phải viết các driver cho mỗi platform, nhiệm vụ của driver là ánh xạ định dạng dữ liệu của mỗi platform về định dạng dữ liệu chung của ontology. Để chứng minh khả năng mở rộng của hệ thống, tôi xây dựng driver cho hai nền tảng IoT là HomeAssistant và OpenHAB để ánh xạ định dạng dữ liệu của hai nền tảng này về định dạng của ontology. Sau đó, đến phần thực nghiệm khả năng mở rộng của hệ thống tôi sẽ thêm một nền tảng IoT khác là Thingsboard rồi tích hợp vào hệ thống bằng cách viết thêm một driver cho nền tảng này.\\
%Sau khi đã có một định dạng dữ liệu thống nhất, ta phải dùng ngôn ngữ hình thức để biểu diễn các khái niệm trong ontology. Ở đề tài này, tôi dùng định dạng json để biểu diễn các khái niệm, các thuộc tính của các khái niệm cũng như mối quan hệ giữa các khái niệm. 

%\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.6]{image/mapping_service}
	\caption{Mô hình ánh xạ dữ liệu về một chuẩn của ontology}
\end{figure}

Định dạng dữ liệu của OpenHAB:
%\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.6]{image/openhab_dataformat}
	\caption{Định dạng dữ liệu của OpenHAB}
\end{figure}
\clearpage

Định dạng dữ liệu của HomeAssistant
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.6]{image/homeassistant_dataformat}
	\caption{Định dạng dữ liệu của HomeAssistant}
\end{figure}

Sau khi qua thành phần ánh xạ, dữ liệu của hai nền tảng IoT sẽ được chuẩn hóa về định dạng của ontology.
%Định dạng dữ liệu của ontology:
%\begin{figure}[h!]
%	\center
%	\includegraphics[scale=0.6]{image/ontology_dataformat}
%	\caption{Định dạng dữ liệu của Ontology}
%\end{figure}
\section{Xây dựng cơ chế truy vấn ngữ nghĩa}
\subsection{Cơ chế truy vấn ngữ nghĩa}
Từ các thực thể được biểu diễn theo ontology, ta phải xây dựng cơ chế để lấy được thông tin của các thực thể, mối quan hệ giữa các thực thể. Để làm được điều này, tôi xây dựng tập các API dựa vào mối quan hệ giữa các khái niệm để đạt được tính ngữ nghĩa. Đồng thời, tôi định nghĩa ra cấu trúc của một truy vấn đơn giản, sử dụng tập API trên để tạo ra các câu truy vấn ngữ nghĩa. Tôi cũng sử dụng định dạng json để biểu diễn các câu truy vấn để đơn giản hóa trong việc phân tích cấu trúc của câu truy vấn. Cấu trúc của một câu truy vấn bao gồm các thành phần: 

Nhánh query của một statement tương ứng với việc thực hiện một câu truy vấn ngữ nghĩa. Để thực hiện câu truy vấn, ta cần chỉ rõ muốn lấy thuộc tính hay khái niệm nào, tập các thuộc tính và khái niệm được gọi là "keyword". Ngoài việc chỉ rõ các thuộc tính, khái niệm cần truy vấn, ta cũng cần chỉ rõ điều kiện thực hiện câu truy vấn. Điều kiện này được chứa trong thành phần "Condition". Một chức năng khác mà ta mong muốn có thể thực hiện là kiểm tra các điều kiện, nếu điều kiện thỏa mãn thì thực hiện một hành động nào đó, hành động này tương ứng với việc điều khiển các thiết bị IoT dựa trên các API mà các platform cung cấp. Chức năng này được gọi là rule.


\begin{figure}[h!]
	\center
	\includegraphics[scale=0.3]{image/language_model-statement}
	\caption{Mô hình ngôn ngữ - statement}
\end{figure}

%Ví dụ một Statement: \\ 


\myexample{Ví dụ một Statement}{
\{\\
\blank{1cm}"select" : "Source",\\
\blank{1cm}"where" : \{\\
\blank{2cm}"condition" : \{\\
%\blank{3cm}"compare" : \{\\
%\blank{4cm}    "keyword" : "SmartContextName",\\
%\blank{4cm}    "comparator" : "=",\\
%\blank{4cm}    "expression" : "HPCC"\\
%\blank{3cm}\},\\
%\blank{3cm}"logic" : \{\},\\
%\blank{3cm}"in\_bracket" : \{\}\\
\blank{2cm}\}\\
\blank{1cm}\}\\
\}\\
}



Một condition là một phép so sánh giữa giá trị tương ứng một keyword với một biểu thức. Ví dụ so sánh PlatformId = "OpenHAB\_id". Các phép so sánh có thể có là <, >, >=, <=, =, !=. Tùy thuộc vào keyword mà có phép so sánh tương ứng. Condition cũng có thể là kết quả của một phép toán logic của một tập hợp các condition khác. Hai phép toán logic hỗ trợ là AND và OR. Ngoài ra, để thể hiện thứ tự ưu tiên của các phép toán logic, ta đưa thêm cặp dấu ngoặc đơn vào ngôn ngữ.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.3]{image/language_model-condition}
	\caption{Mô hình ngôn ngữ - condition}
\end{figure}


\myexample{Ví dụ một Condition}{
\{\\
%\blank{1cm}"select" : "Source",\\
%\blank{1cm}"where" : \{\\
\blank{1cm}"condition" : \{\\
\blank{2cm}"compare" : \{\\
\blank{3cm}    "keyword" : "SmartContextName",\\
\blank{3cm}    "comparator" : "=",\\
\blank{3cm}    "expression" : "HPCC"\\
\blank{2cm}\},\\
\blank{2cm}"logic" : \{\},\\
\blank{2cm}"in\_bracket" : \{\}\\
\blank{1cm}\}\\
%\blank{1cm}\}\\
\}\\
}

Một Action (hành động) là một lời gọi tới các API để điều khiển các thiết bị từ nền tảng IoT. Do các thiết bị trong hệ thống chỉ cung cấp hai thao tác điều khiển là bật và tắt nên ngôn ngữ chỉ đưa vào hai hành động là bật và tắt. Một Action cũng có thể là một danh sách các Action, khi đó, hệ thống sẽ thực hiện lần lượt các Action được liệt kê trong danh sách.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_model-action}
	\caption{Mô hình ngôn ngữ - action}
\end{figure}


\myexample{Ví dụ một Action}{
\blank{0cm}\{\\
\blank{1cm}    "metric\_id" : "led\_id\_1",\\
\blank{1cm}    "value" : turn on\\
\blank{0cm}\},\\
%\blank{0cm}\},\\
}

Một Expression (biểu thức) là một toán tử hoặc các phép toán cộng, trừ các toán tử.
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_model-expression}
	\caption{Mô hình ngôn ngữ - expression}
\end{figure}

Ví dụ một Expression: \\
\myexample{Ví dụ một Expression}{
\blank{0cm}\{\\
\blank{1cm}    "expression" : "HPCC"\\
\blank{0cm}\}
}


Một Term (toán tử) là một hằng số hoặc các phép toán của các hằng số.
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_model-term}
	\caption{Mô hình ngôn ngữ - term}
\end{figure}
%Ví dụ: 3*4/5 là một Term
\myexample{Ví dụ một Term}{
    3*4/5 là một Term
}
Một Const (hằng số) là một chuỗi hoặc một số (nguyên hoặc thực).
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_model-const}	
	\caption{Mô hình ngôn ngữ -const}
\end{figure}

\myexample{Ví dụ một Const}{
    "HPCC" là một chuỗi hay là một Const 
}
\clearpage

\subsection{Ca sử dụng tổng quát}

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.6]{image/language_diagram-use_case}
	\caption{Biểu đồ use case tổng quát}
\end{figure}


\begin{longtable}{|p{140mm}|}
\hline
%\multicolumn{1}{c|}{}\\
Tên ca sử dụng: Statement\\
\hline
Tác nhân chính: Người dùng\\
\hline
Các nhân tố và mối quan tâm: Người dùng muốn sử dụng hệ thống\\
\hline
Mô tả ngắn gọn: Gọi tới các ca sử dụng StatementQuery và StatementRule để phân tích câu truy vấn và trả về kết quả cho người sử dụng.\\
\hline
Kích hoạt: Người dùng gửi một câu truy vấn/luật tới cho Statement\\
\hline
Luồng sự kiện chính: \\
\begin{enumerate}
	\item Người dùng gửi một câu truy vấn/luật 
	\item Statement phân tích, trả về kết quả tương ứng với câu truy vấn/luật mà người dùng yêu cầu.
\end{enumerate}\\
\hline
Luồng sự kiện con: \\
\hline 
Luồng sự kiện ngoại lệ: \\
\hline
\end{longtable}

\clearpage

\subsection{Biểu đồ lớp của các thành phần của cơ chế truy vấn}

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.35]{image/language_diagram-class_diagram}	
	\caption{Biểu đồ lớp của các thành phần}
\end{figure}

\begin{longtable}{|p{30mm}|p{40mm}|p{30mm}|p{40mm}|}
\hline
\multicolumn{4}{c|}{}\\
%\cline{3-7}
Tên class & Mô tả Class & Tên thuộc tính/phương thức& Mô tả thuộc tính/phương thức\\
\hline
Language & Chưa các keyword trong ontology và chia các keyword này theo các khái niệm trong ontology & list\_key\_word & Danh sách keyword của ontology\\
\cline{3-4}
&& smartcontext\_level & Chứa các keyword là các thuộc tính của SmartContext \\
\cline{3-4}
&& platform\_level & Chứa các keyword là các thuộc tính của Platform \\
\cline{3-4}
&& source\_level & Chứa các keyword là các thuộc tính của Source \\
\cline{3-4}
&& metric\_level & Chứa các keyword là các thuộc tính của metric\\
\cline{3-4}
&& datapoint\_level & Chứa các keyword là các thuộc tính của DataPoint\\
\cline{3-4}
&& list\_comparator & Danh sách các phép toán \\
\cline{3-4}
&& list\_logic & Danh sách các biểu thức logic \\
\hline
Statement & Chứa các phương thức để kiểm tra, thực hiện câu truy vấn/luật & checkQuery & Kiểm tra cú pháp, thực hiện câu truy vấn \\
\cline{3-4}
&& checkRule & Kiểm tra cú pháp, thực hiện luật.\\
\hline
StatementQuery & Kế thừa Statement, thực hiện kiểm tra, thực hiện câu truy vấn & checkQuery & Kiểm tra, thực hiện câu truy vấn\\
\hline
StatementRule & Kế thừa Statement, thực hiện kiểm tra, thực hiện luật & checkRule & Kiểm tra, thực hiện luật\\
\hline
Condition & Kiểm tra điều kiện câu truy vấn/luật & checkCompare & Kiểm tra nhánh compare của điều kiện\\
\cline{3-4}
&& checkLogic & Kiểm tra nhánh Logic của điều kiện\\
\cline{3-4}
&& checkInBracket & Kiểm tra nhanh in-bracket của điều kiện\\
\hline
Action & Thực hiện gọi API của các nền tảng IoT & callAPI & Gọi API của các nền tảng IoT\\
\hline
Expression & kiểm tra biểu thức & checkExpression & Kiểm tra cú pháp, ngữ nghĩa của biểu thức\\
\hline
Term & Kiểm tra toán tử & checkTerm & Kiểm tra cú pháp, ngữ nghĩa của toán tử\\
\hline
Const & Kiểm tra hằng số & checkConst & Kiểm tra một hằng số\\
\hline

\end{longtable}

\subsection{Biểu đồ trình tự của cơ chế truy vấn}

Khi người dùng tạo một câu truy vấn hay một luật (Rule) tới hệ thống, thành phần Statement sẽ phân tích câu đó và chuyển tới các thành phần khác của hệ thống để thực hiện câu đó.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-statement}	
	\caption{Biểu đồ trình tự người dùng thực hiện truy vấn}
\end{figure}

Nếu người dùng tạo một câu truy vấn, thành phần Statement sẽ chuyển câu truy vấn tới thành phần StatementQuery để phân tích câu truy vấn. StatementQuery khi đó sẽ kiểm tra cú pháp câu truy vấn và gọi thành phần Condition để kiểm tra cú pháp và lấy ra kết quả câu truy vấn. Sau khi lấy được kết quả truy vấn từ thành phần Condition, StatementQuery gửi lại kết quả cho Statement.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-statement_query}	
	\caption{Biểu đồ trình tự thực hiện một câu truy vấn}
\end{figure}

Nếu người dùng tạo một luật, thành phần Statement của hệ thống sẽ chuyển luật đó tới StatementRule để kiểm tra điều kiện (Condition) và thực hiện hành động (Action). Để kiểm tra điều kiện, StatementRule gọi tới thành phần Condition của hệ thống. Ứng với kết quả kiểm tra điều kiện, StatementRule sẽ gọi tới thành phần Action để thực hiện các hành động tương ứng.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-statement_rule}	
	\caption{Biểu đồ thực hiện một Rule}
\end{figure}

Thành phần Condition của hệ thống có nhiệm vụ kiểm tra cú pháp của điều kiện. Nếu cú pháp đúng, sẽ thực hiện gọi các API để lấy ra kết quả của các câu truy vấn. 

%\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-condition}	
	\caption{Biểu đồ trình tự kiểm tra một Condition}
\end{figure}

Thành phần Expression sẽ kiểm tra tính đúng đắn về cú pháp của một biểu thức. Một biểu thức phải là một toán tử (Term) hoặc một biểu thức gồm các phép cộng, trừ các toán tử. Nếu là một biểu thức, toán tử phải là các số nguyên hoặc số thực, không được là một chuỗi ký tự.

\clearpage
\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-expression}	
	\caption{Biểu đồ trình tự kiểm tra một Expression}
\end{figure}

Thành phần Action sẽ thực hiện các lời gọi API tới các nền tảng IoT để điều khiển các thiết bị.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-action}	
	\caption{Biểu đồ trình tự thực hiện một Action}
\end{figure}

Thành phần Term sẽ kiểm tra một toán tử. Một toán tử phải là một hằng số hoặc một biểu thức gồm các phép nhân, chia các hằng số. Nếu toán tử là một biểu thức, hằng số phải là một số, không được là một chuỗi ký tự.

\begin{figure}[h!]
	\center
	\includegraphics[scale=0.4]{image/language_diagram-term}	
	\caption{Biểu đồ trình tự kiểm tra một Term}
\end{figure}


\subsection{Tập các API}
Để cài đặt cơ chế ngữ nghĩa, tôi đã xây dựng tập các API, các API này dựa vào mối quan hệ giữa các khái niệm trong ontology để thực hiện các câu truy vấn ngữ nghĩa. \\

Các API cơ bản:

\begin{itemize}
	\item Lấy tất cả các Data Point
	\item Lấy tất cả các Metric
	\item Lấy tất cả các Source
	\item Lấy tất cả các Platform
	\item Lấy tất cả các Smart Context
	\item Lấy tất cả các Smart Context nằm trong Smart Context nào đó. (lấy smart context con)
	\item Lấy tất cả các Smart Context chứa Smart Context nào đó. (lấy smart context cha)
\end{itemize}

Một số API phụ trợ:
\begin{itemize}
	\item Lấy DataPointId/DataPoint của một DataPoint
	\item Lấy MetricId/Metric của một Metric
	\item Lấy SourceId/Source của một Source
	\item Lấy PlatformId/Platform của một Platform
	\item Lấy SmartContextId/SmartContext của một SmartContext
\end{itemize}


Các API thể hiện tính ngữ nghĩa dựa trên mối quan hệ giữa các khái niệm:
\begin{itemize}
	\item Lấy DataPoint từ một Metric
	\item Lấy DataPoint từ một Source
	\item Lấy DataPoint từ một Platform
	\item Lấy DataPoint từ một SmartContext
	\item Lấy Metric từ một DataPoint
	\item Lấy Metric từ một Source
	\item Lấy Metric từ một Platform
	\item Lấy Metric từ một SmartContext
	\item Lấy Source từ một DataPoint
	\item Lấy Source từ một Metric
	\item Lấy Source từ một Platform
	\item Lấy Source từ một SmartContext
	\item Lấy Platform từ một DataPoint
	\item Lấy Platform từ một Metric
	\item Lấy Platform từ một Source
	\item Lấy Platform từ một SmartContext
	\item Lấy SmartContext từ một DataPoint
	\item Lấy SmartContext từ một Metric
	\item Lấy SmartContext từ một Source
	\item Lấy SmartContext từ một Platform
\end{itemize}


Ví dụ về cơ chế ngữ nghĩa trong API: Lấy DataPoint từ một SmartContext.
Các bước để lấy DataPoint từ SmartContext:
\begin{enumerate}
	\item lấy ra các Platform mà Smart Context đó chứa dựa vào mối quan hệ hasPlatform của SmartContext.
	\item với mỗi Platform, xác định xem nó chứa các Source nào dựa vào mối quan hệ hasSource của Platform.
	\item với mỗi Source, xác định xem nó chứa các Metric nào dựa vào mối quan hệ hasMetric của Source.
	\item với mỗi Metric, xác định DataPoint mà nó chứa dựa vào thuộc tính hasDataPoint của Metric.
\end{enumerate}

Vậy sau khi duyệt qua các quan hệ trên ontology, ta sẽ lấy ra được các DataPoint nằm trong một SmartContext. Cơ chế truy vấn ngữ nghĩa này hoàn toàn tương tự đối với các API khác được xây dựng.